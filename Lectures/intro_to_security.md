# Security 

Security is an especially important consideration when working with medical software and devices. We will introduce key security concepts at a high-level in lecture today.

## Outline
- Terminology
  - Encryption (plaintext, ciphertext)
  - Signing (verification)
  - Encryption vs. Signing
  - __"Encryption at Rest" ([AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard), see [PyCryptodome](https://www.pycryptodome.org/)) (HIPPA)__
  - __"Encryption in Transit" ([TLS/SSL](https://en.wikipedia.org/wiki/Transport_Layer_Security)) (HIPPA)__
  - "End-to-end encryption" (E2EE)
- [Asymmetric encryption](https://en.wikipedia.org/wiki/Public-key_cryptography)
  - "Pairs" of related keys are generated by Alice--one to be kept private, one to be shared publically. [Learn more](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Operation) about how key pairs are generated.
  - Anyone can use Alice's public key to encrypt a message that can __only be decrypted by Alice's private key__.
  - Alice can use her private key to digitally "sign" a message that can be __verified as authentic (actually sent by Alice) and unmodified__ by anyone who has her public key
  - Two parties, each with their own public/private key pair can share their public keys with each other, allowing those two parties to communicate back and forth securely (used on the internet a lot). [Learn more](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange). 
  - This type of encryption underlies TLS/SSL, and is used for securely communicating with remote servers. This allows both the client and server to 1) establish and verify that communications are being sent/received from the actual party (and not an imposter) and 2) to have the communications only decipherable by the server and client involved (no eavesdropper can see what is being communicated). 
- [TLS/SSL](https://en.wikipedia.org/wiki/Transport_Layer_Security)
  - Important to ensure communications between clients and servers are not observed by eavesdroppers
  - __Also__ important to ensure that the client can verify the identity of the server (ensure that no malicious party is masquerading as the server). 
  - Certificate Authorities (CAs) are responsible for "vouching" for the identity of a server.
<!--- 
## Add TLS/SSL to your server
You can add TLS/SSL to your server pretty easily (and for free) these days because of certificate authorities like [Let's Encrypt](https://letsencrypt.org/) that make verification easy. Tools like [`ssl-proxy`](https://github.com/suyashkumar/ssl-proxy) (disclaimer: this was built by @suyashkumar) make negotiating and serving a LetsEncrypt certificate as easy as running a single command. You may also acquire certificates using [certbot](https://certbot.eff.org/) and incoporate them manually into [Flask](https://stackoverflow.com/questions/28579142/attributeerror-context-object-has-no-attribute-wrap-socket/28590266#28590266).

## Using ssl-proxy
- Login to your Duke virtual machine.
- Download the latest release of [`ssl-proxy`](https://github.com/suyashkumar/ssl-proxy) to your virtual machine:
  ```sh
  wget -qO- https://github.com/suyashkumar/ssl-proxy/releases/download/v0.2.2/ssl-proxy-linux-amd64.tar.gz | tar xvz
  sudo mv ssl-proxy-linux-amd64 /usr/local/bin/ssl-proxy # Move the command into your path, rename as ssl-proxy
  ```
- Create a screen, and run your flask web server, ensure that you have `127.0.0.1` set as your host (only allowing incoming requests from the VM, preventing the outside world from sending requests to your server directly). This example assumes your port is :5000.
- In another screen, run `ssl-proxy` as follows:
  ```sh
  sudo ssl-proxy -from 0.0.0.0:443 -to 127.0.0.1:5000 -domain $YOUR_VCM_DOMAIN_NAME_HERE
  ```
  This command will negotiate, fetch, and install an ssl certificate for you and serve that ssl certificate on port 443 (the default port for SSL, whenever you go to a website using `https://`). It will take all incoming web traffic served and negotiated using SSL/TLS, and then send it along to your web service listening for incoming requests at `127.0.0.1:5000`. :eyes: Notice that in this example we asked you to list the `127.0.0.1` loopback as your host because `127.0.0.1` will not allow external connections outside of your VCM to send requests to the flask server. Since the `ssl-proxy` program is running on your VM, it is allowed to send connections, but no one else can attempt to contact your flask server directly (they must all go through the `ssl-proxy` layer first).
  
- You should now be able to visit your vcm at `https://vcm-7295.vm.duke.edu` (substitute for your vcm address) and see the little security lock in your browser. Clicking on it will let you inspect the certificate. If your server does not have a handler for a default route `/`, then be sure to navigate to your route. For example: `https://vcm-7295.vm.duke.edu/hello`
--->

**Asymmetric Math Example**:  [asymmetric_math.py](lecture_code/asymmetric_math.py)

## In-Class Exercise

We are going to demonstrate how asymmetric encryption can be 
used to send secret information to another person without prior agreement of 
any encryption keys.

We will be using the `pycryptodome` package.  

Complete the following steps.

### Step 1 - Generate Public and Private Keys
```python
from Crypto.PublicKey import RSA

def generate_keys():
    # Generate the RSA public/private key pair
    rsa_key_pair = RSA.generate(2048)
    
    # Output Private Key
    private_key = rsa_key_pair.export_key()
    print(private_key)
    with open("my_private.pem", "wb") as out_file:
        out_file.write(private_key)

    # Output Public Key
    public_key = rsa_key_pair.publickey().export_key()
    print(public_key)
    with open("my_public.pem", "wb") as out_file:
        out_file.write(public_key)
```

### Step 2 - Obtain Public Key From Server
`http://vcm-43716.vm.duke.edu/get_public_key`

Make a request to the GET route above.  It will return a string.  You can 
convert this string into an RsaKey variable as 
follows:
```python
server_public_key = RSA.import_key(response.text)
```

### Step 3 - Encode Your Duke Net ID Using The Server Public Key
In this step, we are first going to encrypt the data we want to send 
secretly (your Duke Net ID) using asymmetric encryption.

```python
from Crypto.Cipher import PKCS1_OAEP

# Secret data to be sent, in byte string format
data = "<Your_Duke_Net_ID>".encode("utf-8")
    
# Use server public key to asymmetrically encode data
rsa_encoder = PKCS1_OAEP.new(server_public_key)
encrypted_data = rsa_encoder.encrypt(data)
    
```

### Step 4 - Get your public key
You are going to send your public key to the server.  To load that in, use
the following:
```python
with open("my_public.pem", 'rb') as in_file:
    my_public_key_str = in_file.read()

```


### Step 5 - Post this encrypted data to the server
`http://vcm-43716.vm.duke.edu/post_message`

Send a json to the above POST route with the following format:
```python
import base64

out_json = {
            "message": str(base64.b64encode(encrypted_data), 
                           encoding='utf-8'),
            "public_key": str(base64.b64encode(my_public_key_str), 
                              encoding='utf-8') 
           }
```

### Step 6 - Decrypt Data Using Private Key
The request in Step 5 will return an base64 encrypted string.  Decrypt that 
string 
as follows:

```python
# Load in your private key
with open("my_private.pem", 'rb') as in_file:
    private_key = RSA.import_key(in_file.read())

# Convert base64 string to byte string
ciphertext = base64.b64decode(request.text)
rsa_decoder = PKCS1_OAEP.new(private_key)
message = rsa_decoder.decrypt(ciphertext)
passcode = str(message, encoding='utf-8')

```

### Step 7 - Check passcode
To ensure everything worked, make a request to this GET route:

`http://vcm-43716.vm.duke.edu/check/<duke_net_id>/<passcode>`

where `<duke_net_id>` is your Duke Net ID and `<passcode>` is the passcode 
you decrypted above.  This request will return a string of either Correct 
or Incorrect.
