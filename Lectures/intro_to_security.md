# Security 

Security is an especially important consideration when working with medical software and devices. We will introduce key security concepts at a high-level in lecture today.

## Outline
- Terminology
  - Encryption (plaintext, ciphertext)
  - Signing (verification)
  - Encryption vs. Signing
  - __"Encryption at Rest" ([AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard), see [PyCryptodome](https://www.pycryptodome.org/)) (HIPPA)__
  - __"Encryption in Transit" ([TLS/SSL](https://en.wikipedia.org/wiki/Transport_Layer_Security)) (HIPPA)__
  - "End-to-end encryption" (E2EE)
- [Asymmetric encryption](https://en.wikipedia.org/wiki/Public-key_cryptography)
  - "Pairs" of related keys are generated by Alice--one to be kept private, one to be shared publically. [Learn more](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Operation) about how key pairs are generated.
  - Anyone can use Alice's public key to encrypt a message that can __only be decrypted by Alice's private key__.
  - Alice can use her private key to digitally "sign" a message that can be __verified as authentic (actually sent by Alice) and unmodified__ by anyone who has her public key
  - Two parties, each with their own public/private key pair can share their public keys with each other, allowing those two parties to communicate back and forth securely (used on the internet a lot). [Learn more](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange). 
  - This type of encryption underlies TLS/SSL, and is used for securely communicating with remote servers. This allows both the client and server to 1) establish and verify that communications are being sent/received from the actual party (and not an imposter) and 2) to have the communications only decipherable by the server and client involved (no eavesdropper can see what is being communicated). 
- [TLS/SSL](https://en.wikipedia.org/wiki/Transport_Layer_Security)
  - Important to ensure communications between clients and servers are not observed by eavesdroppers
  - __Also__ important to ensure that the client can verify the identity of the server (ensure that no malicious party is masquerading as the server). 
  - Certificate Authorities (CAs) are responsible for "vouching" for the identity of a server.
 
## Add TLS/SSL to your server
You can add TLS/SSL to your server pretty easily (and for free) these days because of certificate authorities like [Let's Encrypt](https://letsencrypt.org/) that make verification easy. Tools like [`ssl-proxy`](https://github.com/suyashkumar/ssl-proxy) (disclaimer: this was built by @suyashkumar) make negotiating and serving a LetsEncrypt certificate as easy as running a single command. You may also acquire certificates using [certbot](https://certbot.eff.org/) and incoporate them manually into [Flask](https://stackoverflow.com/questions/28579142/attributeerror-context-object-has-no-attribute-wrap-socket/28590266#28590266).

## Using ssl-proxy
- Login to your Duke virtual machine.
- Download the latest release of [`ssl-proxy`](https://github.com/suyashkumar/ssl-proxy) to your virtual machine:
  ```sh
  wget -qO- https://github.com/suyashkumar/ssl-proxy/releases/download/v0.2.2/ssl-proxy-linux-amd64.tar.gz | tar xvz
  sudo mv ssl-proxy-linux-amd64 /usr/local/bin/ssl-proxy # Move the command into your path, rename as ssl-proxy
  ```
- Create a screen, and run your flask web server, ensure that you have `127.0.0.1` set as your host (only allowing incoming requests from the VM, preventing the outside world from sending requests to your server directly). This example assumes your port is :5000.
- In another screen, run `ssl-proxy` as follows:
  ```sh
  sudo ssl-proxy -from 0.0.0.0:443 -to 127.0.0.1:5000 -domain $YOUR_VCM_DOMAIN_NAME_HERE
  ```
  This command will negotiate, fetch, and install an ssl certificate for you and serve that ssl certificate on port 443 (the default port for SSL, whenever you go to a website using `https://`). It will take all incoming web traffic served and negotiated using SSL/TLS, and then send it along to your web service listening for incoming requests at `127.0.0.1:5000`. :eyes: Notice that in this example we asked you to list the `127.0.0.1` loopback as your host because `127.0.0.1` will not allow external connections outside of your VCM to send requests to the flask server. Since the `ssl-proxy` program is running on your VM, it is allowed to send connections, but no one else can attempt to contact your flask server directly (they must all go through the `ssl-proxy` layer first).
  
- You should now be able to visit your vcm at `https://vcm-7295.vm.duke.edu` (substitute for your vcm address) and see the little security lock in your browser. Clicking on it will let you inspect the certificate. If your server does not have a handler for a default route `/`, then be sure to navigate to your route. For example: `https://vcm-7295.vm.duke.edu/hello`
  
## In-Class Exercise

We are going to demonstrate how asymmetric and symmetric encryption can be 
used to send secret information to another person without prior agreement of 
any encryption keys.

We will be using the `pycryptodome` package.  

With a partner, complete the following steps.

### Step 1 - Generate Public and Private Keys
```python
from Crypto.PublicKey import RSA

def generate_keys():
    # Generate the RSA public/private key pair
    rsa_key_pair = RSA.generate(2048)
    
    # Output Private Key
    private_key = rsa_key_pair.export_key()
    print(private_key)
    with open("my_private.pem", "wb") as out_file:
        out_file.write(private_key)

    # Output Public Key
    public_key = rsa_key_pair.publickey().export_key()
    print(public_key)
    with open("my_public.pem", "wb") as out_file:
        out_file.write(public_key)
```

### Step 2 - Share Public Key with Partner
Exchange public key files with your partner.  When you receive your partner's
public key file, rename it as "recipient_public_key.pem"

### Step 3 - Encode Your Message to Partner Using Their Public Key
In this step, we are first going to encrypt the data we want to send 
secretly using symmetric AES encryption.  Then, to be able to send this 
encrypted text and its key safely, we will encrypt the AES key using
asymmetric encryption and the recipient's public key.

```python
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from Crypto.Cipher import AES, PKCS1_OAEP

def encrypt():
    # Secret data to be sent
    data = "Enter the secret only your partner should read".encode("utf-8")
    
    # Generate a random key to use for symmetric encryption with AES
    aes_key = get_random_bytes(16)
    
    # Encrypt secret data with AES
    aes_encoder = AES.new(aes_key, AES.MODE_EAX)
    ciphertext, tag = aes_encoder.encrypt_and_digest(data)
    
    # Need to send aes_key and cipher text to recipient.
    # But, if I send both and message intercepted, user could decrypt using
    #   the sent aes_key.
    # So, encrypt aes_key with asymmetric encryption that only recipient
    #   can decrypt
    
    # Get recipient public key
    recipient_public_key = RSA.import_key(
      open("recipient_public_key.pem", 'rb').read())
    
    # Use recipient public key to asymmetrically encode the aes_key
    rsa_encoder = PKCS1_OAEP.new(recipient_public_key)
    encrypted_aes_key = rsa_encoder.encrypt(aes_key)
    
    # Place needed data into file to send
    with open("encrypted_data_to_send.bin", 'wb') as out_file:
        [out_file.write(x) for x in (encrypted_aes_key,
                                     aes_encoder.nonce,
                                     tag,
                                     ciphertext)]
```

### Step 4 - Share Your Message With Partner
Send your partner the "encrypted_data_to_send.bin" file with your partner.
When you receive your partner's file, rename it to 
"received_encrypted_data.bin".

### Step 5 - Decrypt Data Using Private Key
Now, only you can decode the "received_encrypted_data.bin" file as only you
have the private key to do so.

```python
from Crypto.PublicKey import RSA
from Crypto.Cipher import AES, PKCS1_OAEP

def decrypt():
    # Load in your private key
    with open("my_private.pem", 'rb') as in_file:
        private_key = RSA.import_key(in_file.read())

    # Read-in data from the received file
    with open("received_encrypted_data.bin", 'rb') as in_file:
        encrypted_aes_key = in_file.read(private_key.size_in_bytes())
        nonce = in_file.read(16)
        tag = in_file.read(16)
        ciphertext = in_file.read()

    # Decrypt the AES key with the private key
    rsa_decoder = PKCS1_OAEP.new(private_key)
    aes_key = rsa_decoder.decrypt(encrypted_aes_key)

    # Decrypt the data with the AES session key
    aes_decoder = AES.new(aes_key, AES.MODE_EAX, nonce)
    data = aes_decoder.decrypt_and_verify(ciphertext, tag)
    print(data.decode("utf-8"))
```

### Step 6 - Continued Communication
Now, if you wanted to continue to share information, you would now only need
to use the AES key that you now both have and no one else should have.


